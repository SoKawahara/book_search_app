銀行口座データベース
chapter2
1. SELECT 口座番号 ,名義,種別,残高,更新日
     FROM 口座
2. SELECT 口座番号
     FROM 口座
3. SELECT 口座番号 , 残高
     FROM 口座　
4. SELECT *
     FROM 口座
5. UPDATE 口座
      SET 名義 = 'X X X X X'
6. UPDATE 口座
      SET 残高 = 99999999 , 更新日 = '2024-03-01'
7. INSERT INTO 口座　
   VALUES ('0642191' , 'アオキ ハルカ' , '1' , 3640551 , '2024-03-13')
   INSERT INTO 口座　
   VALUES ('1039410' , 'キノシタ リュウジ' , '1' , 259017 , '2013-11-30')
   INSERT INTO 口座　(口座番号 , 名義 , 種別 , 残高)
   VALUES ('1239855' , 'タカナシ ミツル' , '2' , 6509773)
8. DELETE FROM 口座
9. SELECT *
     FROM 口座 
    WHERE 口座番号 = '0037651'
10. SELECT *
      FROM 口座
     WHERE 残高 > 0
11. SELECT *
      FROM 口座 
     WHERE 口座番号 < '1000000'
12. SELECT *
      FROM 口座 
     WHERE 更新日 < '2023-01-01'
13. SELECT *
      FROM 口座
     WHERE　残高 >= 1000000
14. SELECT *
      FROM 口座 
     WHERE 種別 <> '1'
15. SELECT *
      FROM 口座 
     WHERE 更新日 IS NULL
16. SELECT *
      FROM 口座　
     WHERE 名義 LIKE '%ハシ%'
17. SELECT * 
      FROM 口座　
     WHERE 更新日 BETWEEN '2024-01-01' AND '2024-01-31'
18. SELECT *
      FROM 口座　
     WHERE 種別 IN ('2' , '3)
19. SELECT *
      FROM 口座　
     WHERE 名義 IN ('サカタ リョウヘイ' , 'マツモト ミワコ' , 'ハマダ サトシ')
20. SELECT *
      FROM 口座　
     WHERE 更新日 BETWEEN '2023-12-30' AND '2024-01-04'
21. SELECT *
      FROM 口座 
     WHERE 残高 < 10000 AND 更新日 IS NOT NULL
22. SELECT *
      FROM 口座 
     WHERE (口座番号 BETWEEN '2000000' AND '2999999') OR 
           (名義 LIKE 'エ%' AND 名義 LIKE '%コ')
23.　口座テーブル→口座番号
　　　取引テーブル→取引番号
　　　取引事由テーブル→取引事由ID
24. SELECT * 
      FROM 口座 
     ORDER BY 口座番号 
25. SELECT DISTINCT 名義
      FROM 口座 
     ORDER BY 名義
26. SELECT * 
      FROM 口座
    ORDER BY 4 DESC , 1 
27. SELECT 更新日
      FROM 口座 
     WHERE 更新日 IS NOT NULL
    ORDER BY 更新日 
    OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
28. SELECT 更新日 , 残高
      FROM 口座 
     WHERE 残高 <> 0 OR 更新日 IN NOT NULL
    ORDER BY 残高 , 更新日 DESC
29. SELECT 口座番号 FROM 口座
     UNION 
    SELECT 口座番号 FROM 廃止口座
    ORDER BY 口座番号 DESC
30. SELECT 口座番号 FROM 口座 
     MINUS 
    (SELECT 口座番号 FROM 口座
      UNION 
     SELECT 口座番号 FROM 廃止口座)
     ORDER BY 口座番号 DESC
31. SELECT 名義 FROM 口座 
    INTERSECR 
    SELECT 名義 FROM 廃止口座
    ORDER BY 口座番号
32. SELECT 口座番号 , 残高 FROM 口座 WHERE 残高 = 0
     UNION 
    SELECT 口座番号 , 残高 FROM 廃止口座 WHERE 解約時残高 <> 0
    ORDER BY 口座番号
33. SELECT 口座番号 + '〇' AS 口座番号 , 残高 FROM 口座 
     UNION 
    SELECT 口座番号 + '✕' AS 口座番号, 残高 FROM 廃止口座
    ORDER BY 名義 
34. SELECT 口座番号 , TRUNC(残高 , -3) AS 千円単位の切り捨て
      FROM 口座 
     WHERE 残高 >= 1000000
35. INSERT INTO 口座 
    VALUES ('0652281' , 'タカギ　ノブオ' , '1' , 100000 + 3000 , '2024-04-01')
    INSERT INTO 口座 
    VALUES ('1026413' , 'マツモト　サワコ' , '1' , 300000 + 3000 , '2024-04-02')
    INSERT INTO 口座 
    VALUES ('2239710' , 'ササキ　シゲノリ' , '1' , 1000000 + 3000 , '2024-04-03')
36. UPDATE 口座
       SET 残高 = 残高 - 3000
     WHERE 口座番号 IN ('0652281' , '1026413' , '2239710')
    
    UPDATE 口座 
       SET = 残高 + (残高 * 0.003)
     WHERE 口座番号 IN ('0652281' , '1026413' , '2239710')
37. SELECT 口座番号 , 更新日 , 更新日 + 180 AS 通帳期限日
      FROM 口座 
     WHERE 更新日 < '2022-01-01'
38. SELECT 口座番号 , 'カ' + 名義 AS 名義
      FROM 口座 
     WHERE 種別 = '3'
39. SELECT DISTINCT 種別 AS 種別コード,
      CASE 種別コード WHEN '1' THEN '普通'
                     WHEN '2' THEN '当座'
                     WHEN '3' THEN '別段' END AS 種別名
40. SELECT 口座番号 , 名義 ,
      CASE WHEN 残高 < 100000 THEN 'C'
           WHEN 残高 BETWEEN '100000' AND '999999' THEN 'B'
           ELSE 'A' END AS 残高ランク
     FROM 口座 
41. SELECT 口座番号 , 名義 , LENGTH(REPLACE(名義 , '　' , '')) AS 名義の文字数
      FROM 口座 
42. SELECT SUBSTRING(名義 , 1 , 5) LIKE '%カワ%' AS 名義
      FROM 口座
43. SELECT *
      FROM 口座 
     WHERE LENGTH(CAST(残高 AS VARCHAR(20))) >= 4 AND SUBSTRING(残高 , -3 , 3) = '000'
44. SELECT 口座番号 , 残高 , TRUNC(残高 * 0.00002) AS 利息
      FROM 口座 
45. SELECT 口座番号 , 残高 , 
      CASE WHEN 残高 < 500000 THEN TRUNC(残高 * 0.0001)
           WHEN 残高 BETWEEN 500000 AND 1999999 THEN TRUNC(残高 * 0.0002)
           WHEN 残高 >= 2000000 THEN TRUNC(残高 * 0.0003) END AS 残高別利息
     FROM 口座 
     ORDER BY 口座番号 
46. INSERT INTO 口座 VALUES('0351262' , 'イトカワ　ダイ' , '2' , 635110 , CURRENT_DATE)
    INSERT INTO 口座 VALUES('1015513' , 'アキツ　シュンジ' , '1' , 88463 , CURRENT_DATE)
    INSERT INTO 口座 VALUES('704610' , 'ホシノ　サトミ' , '1' , 704610 , CURRENT_DATE)
47. SELECT SUBSTRING(CAST(日付 AS CHAR(10)) , 1 , 4) || '年' || SUBSTRING(CAST(日付 AS CHAR(10)) , 6 , 2) || '月' SUBSTRING(CAST(日付 AS CHAR(10)) , 9 , 2) || '日' AS 更新日
      FROM 口座 
     WHERE 更新日 >= '2024-01-01'
48. SELECT COALESCE(更新日 , '設定なし') AS 更新日
      FROM 口座
49. SELECT SUM(残高) AS 残高の合計 , MAX(残高) AS 残高の最大値 , MIN(残高) AS 残高の最小値 , AVG(残高) AS 残高の平均値 , COUNT(*) AS データ件数
      FROM 口座 
50. SELECT COUNT(*)
      FROM 口座 
     WHERE 種別 <> '1' AND 残高 >= 1000000 AND 更新日 < '2023-01-01' 
51. SELECT COUNT(*) - COUNT(更新日) AS 更新日未登録データ
      FROM 口座 
52. SELECT MAX(名義) , MIN(名義)
      FROM 口座 
     GROUP BY 名義 
53. SELECT MAX(更新日) AS 最も新しい更新日 , MIN(更新日) AS 最も古い更新日
      FROM 口座
    GROUP BY 更新日 
54. SELECT 種別 , SUM(残高) AS 残高の合計 , MAX(残高) AS 残高の最大 , MIN(残高) AS 残高の最小 , AVG(残高) AS 残高の平均 , COUNT(*)
      FROM 口座
    GROUP BY 種別 
55. SELECT 口座番号 , COUNT(*) AS データ件数
      FROM 口座 
    GROUP BY SUBSTRING(口座番号 , LENGTH(口座番号) , 1) AS 口座番号
    ORDER BY データ件数 DESC
56. SELECT 更新年 , SUM(残高) , MAX(残高) , MIN(残高) , AVG(残高) , COUNT(*) 
      FROM 口座 
    GRPUP BY COALESCE(SUBSTRING(CAST(更新日 AS VARCHAR) , 1 , 4) , 'XXXX') AS 更新年
57. SELECT 種別 , SUM(残高) , COUNT(*)
      FROM 口座 
    GROUP BY 種別 
    HAVING SUM(残高) >= 3000000
58. SELECT COUNT(*) AS データ件数 , AVG(REPLACE(名義 , ' ' , '')) AS 名義文字数の平均
      FROM 口座 
    GROUP BY SUBSTRING(REPLACE(名義 , ' ' , '') , 1 , 1) AS 名義の１文字目
    HAVING データ件数 >= 10 OR 名義文字数の平均 >= 5
59. UPDATE 口座 
       SET 残高 = (SELECT 残高 + 入金額 - 出金額 AS 残高 
                     FROM 取引 
                    WHERE 口座番号 = '0351333' AND 取引日 = '2024-01-11'
     WHERE 口座番号 = '0351333' AND 取引日 = '2024-01-11')
60. SELECT 残高 , 
           (SELECT 入金額 FROM 取引 WHERE 口座番号 = '1115600' AND 取引日 = '2023-12-28') AS 入金額,
           (SELECT 出金額 FROM 取引 WHERE 口座番号 = '1115600' AND 取引日 = '2023-12-28') AS 出金額
      FROM 口座 
61. SELECT 口座番号 , 名義 , 残高 
      FROM 口座 
     WHERE 口座番号 IN (SELECT 口座番号 FROM 取引 WHERE 入金額 >= 1000000)
62. SELECT * 
      FROM 口座
     WHERE 更新日 > ALL(SELECT 日付 FROM 取引)
63. SELECT 日付 , MAX(入金額) AS 最大 , MIN(入金額) AS 最小 
      FROM (SELECT * FROM 取引 WHERE (入金額 IS NOT NULL) AND (出金額 IS NOT NULL) AND 口座番号 = '3104451')
64. INSERT INTO 口座廃止 ('口座番号' , '名義' , '種別' , '解約時残高' , '解約日')
    SELECT * FROM 口座 WHERE 口座番号 = '2761055'

    DELETE FROM 口座 WHERE 口座番号 = '2761055'
65. SELECT K.口座番号 , T.日付 , T.取引事由 , 
      CASE WHEN K.入金額 > 0 THEN 入金額 
           WHEN K.出金額 > 0 THEN 出金額 END AS 取引金額
      FROM 口座 AS K 
      JOIN 取引 AS T 
        ON K.口座番号 = T.口座番号 AND K.口座番号 IN ('311240' , '1234161' , '2750902')
    GROUP BY K.口座番号 
    ORDER BY 取引番号 
66. SELECT '(' || K.口座番号 || ',' || K.名義 || ',' || K.残高 || ')' AS 口座情報,
           '(' || T.日付 || ',' || T.入金額 || ',' || T.出金額 || ')' AS 取引情報 
      FROM 口座 AS K 
      JOIN 取引 AS T 
        ON K.口座番号 = T.口座番号 AND K.口座番号 = '0887132'
    ORDER BY 日付 
67. SELECT K.口座番号 , K.名義 , K.残高 
      FROM 口座 AS K 
      JOIN 取引 AS T 
        ON K.口座番号 = T.口座番号 AND T.日付 = '2022-03-01'
68. 
69. SELECT T.取引事由ID || ':' || TJ.取引事由名 AS 取引事由 , COUNT(*) AS 取引回数
      FROM 取引 AS T  
      JOIN 取引事由 AS TJ
        ON T.取引事由ID = TJ.取引事由ID 
    GROUP BY T.取引事由ID 
    HAVING COUNT(*) = 0
70. SELECT T.取引事由ID , TJ.取引事由名
      FROM 取引 AS T 
      LEFT JOIN 取引事由 AS TJ 
        ON T.取引事由ID = TJ.取引事由ID
71.  SELECT '(' || K.口座番号 || ',' || K.名義 || ',' || K.残高 || ')' AS 口座情報,
            '(' || T.日付 || ',' || TJ.取引事由名 || ',' ||  T.入金額 || ',' || T.出金額 || ')' AS 取引情報 
       FROM 口座 AS K 
       JOIN 取引 AS T 
         ON K.口座番号 = T.口座番号 
       JOIN 取引事由 AS TJ 
         ON T.取引事由ID = TJ.取引事由ID 
     WHERE T.口座番号 = '0887132'
     ORDER BY T.取引番号
72. SELECT K.口座番号 , K.名義 , K.残高 , T.日付 AS 取引の日付 ,  T.取引事由ID , T.入金額 , T.出金額  
      FROM 口座 AS K
      JOIN 取引 AS T 
        ON K.口座番号 = T.口座番号
     WHERE K.残高 >= 5000000 AND COALESCE(T.入金額 , T.出金額) >= 1000000 AND 日付 >= '2024-01-01'
73. SELECT K.口座番号 , K.名義 , K.残高 , T.日付 AS 取引の日付 , T.取引事由ID , T.入金額 ,T.出金額 
      FROM 口座 AS K 
      JOIN (SELECT * FROM 取引 WHERE COALESCE(入金額 , 出金額) >= 1000000) AS T 
        ON K.口座番号 = T.口座番号 
     WHERE K.残高 >= 5000000
74. SELECT T.日付 AS 日付 , T.口座番号 AS 口座番号 , COUNT(*) AS 取引回数 , K.名義 AS 名義  
      FROM 取引 AS T 
      JOIN 口座 AS K 
        ON T.口座番号 = K.口座番号 
     GROUP BY T.日付 , T.口座番号 
     HAVING COUNT(*) >= 3
75. 



      
       

--------------------------------------銀行口座データベースの正答----------------------------------------
22. SELECT * 
      FROM 口座 
     WHERE 口座番号 LIKE '2______' OR 名義 LIKE 'エ__　%コ'
*LIKE演算子を使用する際にはアンダースコアで任意の1文字を表現することができる→これめちゃ便利じゃね??

28. SELECT 更新日 , 残高
      FROM 口座
     WHERE 残高 = 0 OR 更新日 IS NOT NULL
     ORDER BY 残高 , 更新日 DESC
     OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY 

30. SELECT 名義 FROM 口座 
    EXCEPT
    SELECT 名義 FROM 廃止口座 
    ORDER BY 名義 DESC

34. SELECT 口座番号 , 残高 / 1000 AS 千円単位の残高 
      FROM 口座
     WHERE 残高 >= 1000000

36. UPDATE 口座  
       SET = (残高 - 3000) * 0.013
     WHERE 口座番号 IN ('0652281 , '1026413' , '2239710')

43. SELECT * 
      FROM 口座 
     WHERE LENGTH(CAST(残高 AS VARCHAR(30))) >= 4 AND SUBSTRING(残高 , LENGTH(残高) - 2 , 3) = '000'

48. SELECT COALESCE(CAST(更新日 AS VARCHAR) , '設定なし') AS 更新日
      FROM 口座 

55. SELECT SUBSTRING(口座番号 , 7 , 1) AS 口座番号の下１桁 , COUNT(*) AS 件数 
      FROM 口座
    GROUP BY SUBSTRING(口座番号 , 7 , 1)
    ORDER BY 件数 DESC
56. SELECT COALESCE(SUBSTRING(更新日 , 1 , 4) , 'XXXX') AS 更新年 , SUM(残高) AS 合計 , MAX(残高) AS 最大 , MIN(残高) AS 最小 , AVG(残高) AS 平均 , COUNT(*) AS 件数
       FROM 口座 
    GROUP BY COALESCE(SUBSTRING(更新日 , 1 , 4) , 'XXXX') 
58. SELECT SUBSTRING(名義 , 1 , 1) AS 名義 , COUNT(*) AS 件数 , AVG(LENGTH(REPLACE(名義 , ' ' , ''))) AS 平均
      FROM 口座 
    GROUP BY SUBSTRING(名義 , 1 , 1)
    HAVING COUNT(*) >= 10 OR AVG(LENGTH(REPLACE(名義 , ' ' , ''))) > 5
59 UPDATE 口座
      SET 残高 = 残高 + (SELECT COALESCE(SUM(入金額) , 0) - COALESCE(SUM(出金額) , 0)
                          FROM 取引 WHERE 口座番号 = '0351333' AND 日付 = '2024-01-11') , 更新日 = '2024-01-11'
     WHERE 口座番号 = '0351333'
*カラムの値がNULLになる可能性がある計算を行う際にはCOALESCEで処理を考えた方がいい
60. SELECT 残高,
           (SELECT SUM(入金額) FROM 取引 WHERE 口座番号 = '0351333' AND 取引日 = '2023-12-28') AS 入金額合計,
           (SELECT SUM(出金額) FROM 取引 WHERE 口座番号 = '0351333' AND 取引日 = '2023-12-28') AS 出金額合計
      FROM 口座
63 . SELECT A.日付 , 
           (SELECT MAX(入金額) FROM 取引 WHERE 口座番号 = '3104451') AS 最大入金額,
           (SELECT MAX(出金額) FROM 取引 WHERE 口座番号 = '3104451') AS 最大出金額
     FROM (SELECT 日付 FROM 取引 WHERE 口座番号 = '3104451' GROUP BY 日付 HAVING SUM(入金額) > 0 AND SUM(出金額) > 0) AS A 
*ここでSUM関数を使用しているのは金額がNULLにも0にもなりうるので

     SELECT A.日付 , 
            (SELECT MAX(入金額) FROM 取引 WHERE 口座番号 = '3104451') AS 最大入金額,
            (SELECT MAX(出金額) FROM 取引 WHERE 口座番号 = '3104451') AS 最大出金額
       FROM (SELECT 日付
               FROM 取引 
              WHERE 口座番号 = '3104451'
              HAVING SUM(入金額) > 0 AND SUM(出金額) > 0) AS A 
65. SELECT T.口座番号 , T.日付 , TJ.取引事由名 , COALESCE(T.入金額 , T.出金額) AS 取引金額
      FROM 取引 AS T 
      JOIN 取引事由 AS TJ 
        ON T.取引事由ID = TJ.取引事由ID 
     WHERE 口座番号 IN ('0311240' , '1234161' , '2750902')     
     ORDER BY T.口座番号 , T.取引番号     
*NULLを扱うための方法には初期値の設定のほかに値の比較を行ってNULL出ない方を選択するという使い方もできる
66. SELECT K.口座番号 , K.名義 , K.残高 , T.日付 , T.入金額 , T.出金額
      FROM 口座 AS K 
      JOIN 取引 AS T 
        ON K.口座番号 = T.口座番号
     WHERE K.口座番号 = '0887132'
    ORDER BY T.取引番号
67. SELECT T.口座番号 , K.名義 , K.残高 , T.日付 , T.入金額 , T.出金額 
      FROM 取引 AS T 
      JOIN 口座 AS K 
        ON T.口座番号 = K.口座番号 WHERE T.日付 = '2022-03-01'
68. SELECT T.取引番号 , COALESCE(K.名義 , '解約済み') AS 名義 , COALESCE(K.残高 , 0) AS 残高 
      FROM 取引 AS T 
      LEFT JOIN 口座 AS K 
        ON T.口座番号 = K.口座番号 
     WHERE T.日付 = '2022-03-01'
*ON句で指定した口座がないとき口座テーブルのすべてのカラムはNULLになる。そうすると解約した口座の取引情報が取得できなくなるので
左外部結合を用いて取引の内容は失われないようにする
削除された口座ならK.名義の値はNULLになるのでその際はCOALESCEを用いて'解約済み'に設定する

69. SELECT T.取引番号 , CAST(J.取引事由ID AS VARCHAR) || ':' || J.取引事由名 AS 取引事由 , T.日付 , T.口座番号 , T.入金額 , T.出金額
      FROM 取引 AS T 
      RIGHT JOIN 取引事由 AS J 
         ON T.取り引き事由ID = J.取引事由ID
*RIGHT JOINを用いることで新しい取引事由(右側の表に取引事由がない)にも対応できる

70. SELECT DISTINCT COALESCE(T.取引事由ID , J.取引事由ID) , J.取引事由名
      FROM 取引 AS T
      FULL JOIN 取引事由 AS J
        ON T.取引事由ID = J.取引事由ID
74. SELECT K.口座番号 , T.回数 , K.名義
      FROM 口座 AS K 
      JOIN (SELECT 口座番号 , COUNT(*) AS 回数 FROM 取引 GROUP BY 口座番号 , 日付 HAVING COUNT(*) >= 3) AS T
        ON K.口座番号 = T.口座番号 
75. 自己結合を用いた場合
    SELECT DISTINCT K1.名義 , K1.口座番号 , K1.種別 , K1.残高 , K1.更新日
      FROM 口座 AS K1 
      JOIN 口座 AS K1 
        ON K1.名義 = K2.名義 
     WHERE K1.口座番号 <> K2.口座番号
    ORDER BY K1.名義 , K1.口座番号 
*自己結合の結合条件を用いることで１つしか口座を持たない人をフィルタリングできる


------------------------------------------------------------RPGデータベース------------------------------------
1. SELECT ID , 名称 , 職業コード , HP , MP , 状態コード
     FROM パーティ
2. SELECT 名称 AS なまえ, HP AS 現在のHP , MP AS 現在のMP
     FROM パーティ
3. SELECT * 
     FROM イベント 
4. SELECT イベント番号 AS 番号 , イベント名称 AS 場面
     FROM イベント 
5. INSERT INTO パーティ (ID , 名称 , 職業コード , HP , MP , 状態コード) 
   VALUES ('A01' , 'スガワラ' , '21' , 131 , 232 , '03')
   INSERT INTO パーティ (ID , 名称 , 職業コード , HP , MP , 状態コード)
   VALUES ('A02' , 'オーエ' , '10' , 156 , 84 , '00')
   INSERT INTO パーティ (ID , 名称 , 職業コード , HP , MP , 状態コード)
   VALUES ('A03' , 'イズミ' , '20' , 84 , 190 , '00')
*挿入するレコードの列名と型名が順番まで完全に一致していれば明示的に列名を指定する必要はないが
これから先テーブルの定義が変更された際にもSQLを変更する必要がなくなるので推奨される
6. SELECT *
     FROM パーティ 
    WHERE ID = 'C02'
7. UPDATE パーティ 
      SET HP = 120
    WHERE ID = 'A01'
8. SELECT ID , 名称 , HP 
     FROM パーティ 
    WHERE HP < 100
9. SELECT ID , 名称 , MP 
     FROM パーティ 
    WHERE MP >= 100
10. SELECT イベント番号 , イベント名称 , タイプ
      FROM イベント
     WHERE タイプ <> '3'
11. SELECT イベント番号 , イベント名称 
      FROM イベント 
     WHERE イベント番号 <= 5
12. SELECT イベント番号 , イベント名称 
      FROM イベント 
     WHERE イベント番号 > 20
13. SELECT イベント番号 , イベント名称 
      FROM イベント 
     WHERE 前提イベント番号 IS NULL 
14. SELECT イベント番号 , イベント名称 , 後続イベント番号 
      FROM イベント 
     WHERE 後続イベント番号 IS NOT NULL 
15. UPDATE パーティ
       SET 状態コード = '01'
     WHERE 名称 LIKE '%ミ%'
16. SELECT ID , 名称 , HP  
      FROM パーティ
     WHERE HP BETWEEN 120 AND 160 
17. SELECT 名称 , 職業コード
      FROM パーティ
     WHERE 職業コード IN ('01' , '10' , '11')
18 SELECT 名称 , 状態コード 
     FROM パーティ
    WHERE 状態コード NOT IN ('00' , '09')
19. SELECT * 
      FROM パーティ 
     WHERE HP > 100 AND MP > 100
20. SELECT *
      FROM パーティ
     WHERE ID LIKE 'A%' AND 職業コード LIKE '2%'
21. SELECT *
      FROM イベント 
     WHERE タイプ = '1' AND 前提イベント番号 IS NOT NULL AND 後続イベント番号 IS NOT NULL 
22. パーティテーブル→ID
　　イベント→イベント番号
23. SELECT DISTINCT 状態コード
      FROM パーティ
24. SELECT ID , 名称 , 
      FROM パーティ 
    ORDER BY ID 
25. SELECT 名称 , 職業コード 
      FROM パーティ 
    ORDER BY 名称 DESC 
26. SELECT 名称 , HP , 状態コード 
      FROM パーティ 
    ORDER BY 状態コード , HP DESC 
27. SELECT タイプ , イベント番号 , イベント名称 , 前提イベント番号 , 後続イベント番号
      FROM イベント
    ORDER BY 1 , 2
28. SELECT * 
      FROM パーティ
    ORDDER BY HP DESC 
    OFFSET 0 ROWS FETCH NEXT 3 ROWS ONLY
29. SELECT * 
      FROM パーティ 
    ORDER BY MP DESC 
    OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY
30. SELECT イベント番号 FROM イベント 
    EXCEPT 
    SELECT イベント番号 FROM 経験イベント
    ORDER BY イベント番号
31. SELECT イベント番号 FROM イベント WHERE タイプ = '2'
    INTERSECT
    SELECT イベント番号 FROM 経験イベント WHWRE クリア区分 = '1'
32. SELECT CASE WHEN 職業コード LIKE '1%' THEN 'S' 
                WHEN 職業コード LIKE '2%' THEN 'M'
                ELSE 'A' END AS 職業区分 , 職業コード , ID , 名称
      FROM パーティ 
     ORDER BY 職業コード 
33. SELECT 名称 AS 名前 , HP AS 現在のHP , HP + 50 AS 装備後のHP 
      FROM パーティ 
     WHERE 職業コード IN ('11' , '21')
34. UPDATE パーティ 
       SET MP = MP + 20 
     WHERE ID IN ('A01' , 'A03')
35. SELECT 名称 AS なまえ , HP AS 現在のHP , HP * 2 AS 予想されるダメージ 
      FROM パーティ 
36. SELECT 名称 AS なまえ , CAST(HP AS VARCHAR) || '/' || CAST(MP AS VARCHAR) AS HPとMP , 
      CASE 状態コード WHEN '00' THEN NULL 
                     WHEN '01' THEN '眠り'
                     WHEN '02' THEN '毒'
                     WHEN '03' THEN '沈黙'
                     WHEN '04' THEN '混乱'
                     WHEN '09' THEN '気絶' END AS ステータス
37. SELECT イベント番号 , イベント名称
      CASE タイプ WHEN '1' THEN '強制'
                  WHEN '2' THEN 'フリー'
                  WHEN '3' THEN '特殊' AS タイプ , 
      CASE WHEN イベント番号 BETWEEN 1 AND 10 THEN '序盤'
           WHEN イベント番号 BETWEEN 11 AND 17 THEN '中盤'
           ELSE '終盤' END AS 発生時期
38. SELECT 名称 AS 名前 , HP AS 現在のHP , LENGTH(名称) * 10 AS 予想ダメージ 
      FROM パーティ 
39. UPDATE パーティ 
       SET 状態コード = '04'
     WHERE HP % 4 = 0 OR MP % 4 = 0
40. TRUNC(777 * 0.7 , 0)
41. UPDATE パーティ 
       SET HP = ROUND(HP * 1.3 , ) , MP = ROUND(MP * 1.3 , 0)
42. SELECT 名称 AS なまえ , HP , POWER(HP , 0) AS 攻撃1回目 , POWER(HP, 1) AS 攻撃2回目 , POWER(HP , 2) AS 攻撃3回目
      FROM パーティ 
43. SELECT 名称 AS なまえ , HP , 状態コード , 
           CAST(状態コード AS INTEGER) + CASE WHEN 50 >= HP THEN 3
                                            WHEN 51 <= HP AND HP <= 100 THEN 2 
                                            WHEN 101 <= HP AND HP <= 150 THEN 1 
                                            ELSE 0 END AS リスク値 
    ORDER BY リスク DESC , HP 
44. SELECT COALESCE(前提イベント番号 , '前提なし') , イベント番号 , COALESCE(後続イベント番号 , '後続なし') 
      FROM イベント
     WHERE イベント番号 
   


---------------------------------------------------------------------------------------------------------------
商品データベース
1. SELECT 商品コード , 商品名 , 単価 , 商品区分 , 関連商品コード
     FROM 商品 
2. SELECT 商品名 
     FROM 商品 
3. SELECT * 
     FROM 注文
4. SELECT 注文番号 , 注文枝番 , 商品コード 
     FROM 注文
5. INSERT INTO 商品 
   (商品コード , 商品名 , 単価 , 商品区分)
   VALUES ('W0461' , '冬のあったかコート' , 12800 , '1')
   
   INSERT INTO 商品 
   (商品コード , 商品名 , 単価 , 商品区分)
   VALUES ('S0331' , '春のさわやかコート' , 6800 , '1')

   INSERT INTO 商品 
   (商品コード , 商品名 , 単価 , 商品区分)
   VALUES ('A0582' , '秋のシックなコート' , 9800 , '1')
6. SELECT *
     FROM 商品
    WHERE 商品コード = 'W1252' 
7. UPDATE 商品 
      SET 単価 = 500
    WHERE 商品コード = 'S0023'
8. SELECT *
     FROM 商品 
    WHERE 単価 <= 1000
9. SELECT *
     FROM 商品 
    WHERE 単価 >= 50000
10. SELECT * 
      FROM 注文 
     WHERE 注文日 >= '2024-01-01'
11. SELECT *
      FROM 注文 
     WHERE 注文日 <= '2023-11-01'
12. SELECT 商品区分 
      FROM 商品 
     WHERE 商品区分 <> '1'
13. SELECT *
      FROM 注文 
     WHERE クーポン割引料 IS NULL 
14. DELETE FROM 商品 
     WHERE 商品コード LIKE 'N%'
15. SELECT 商品コード , 商品名 , 単価  
      FROM 商品 
     WHERE 商品名 LIKE '%コート%'
16. SELECT 商品コード , 商品区分 
      FROM 商品 
     WHERE 商品区分 IN ('2' , '3' , '9')
17. SELECT *
      FROM 商品 
     WHERE 商品コード BETWEEN 'A0100' AND 'A0500'
18. SELECT *
      FROM 注文 
     WHERE 商品コード IN ('N0501' , 'N1021' , 'N0223')
19. SELECT *
      FROM 商品 
     WHERE 商品区分 = '3' AND 商品名 LIKE '%水玉%'
20. SELECT *
      FROM 商品 
     WHERE 商品名 LIKE '%軽い%' OR 商品名 LIKE '%ゆるふわ%'
21. SELECT *
      FROM 商品 
     WHERE (商品区分 = '1' AND 単価 <= 3000) OR (商品区分 = '3' AND 単価 >= 10000)
22. SELECT 商品コード
      FROM 注文 
     WHERE 数量 >= 3 AND 注文日 BETWEEN '2024-03-01' AND '2024-03-31'
23. SELECT *
      FROM 注文 
     WHERE 数量 >= 10 OR クーポン割引料 IS NOT NULL
24. 商品テーブル→商品コード
    注文→注文日 , 注文番号 , 注文枝番
    *注文テーブルに関しては複合主キーを作っている
25. SELECT 商品コード , 商品名
      FROM 商品
     WHERE 商品区分 = '1'
    ORDER BY 商品コード DESC
26. SELECT 注文日 , 注文番号 , 注文枝番 , 商品コード , 数量 
      FROM 注文 
     WHERE 注文日 >= '2024-03-01'
    ORDER BY 注文日 , 注文番号 , 注文枝番 
27. SELECT DISTINCT 商品コード ORDER BY 商品コード 
28. SELECT 注文日  
      FROM 注文 
    ORDER BY 注文日 DESC
    OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
29. SELECT *
      FROM 商品 
    ORDER BY 単価 , 商品区分 , 商品コード 
    OFFSET 5 ROWS FETCH NEXT 15 ROWS ONLY
30. SELECT * 
      FROM 廃版商品 
     WHERE (廃版日 BETWEEN '2022-12-01' AND '2022-12-31') AND 売上個数 > 100
31. SELECT 商品コード FROM 商品 
    EXCEPT 
    SELECT 商品コード FROM 注文 
32. SELECT 商品コート FROM 商品  
    INTERSECT  
    SELECT 商品コード FROM 注文 
    ORDER BY 商品コード DESC 
33. SELECT 商品コード , 商品名 , 単価 
      FROM 商品
     WHERE 商品区分 = '9' AND (単価 <= 1000 OR 単価 > 10000)
    ORDER BY 単価 , 商品コード 
34. SELECT 商品コード , 単価 , TRUNC(単価 * 0.95 , 0) AS キャンペーン価格
      FROM 商品 
     WHERE 商品区分 = '9'
    ORDER BY 商品コード 
35. UPDATE 注文 
       SET クーポン割引料 = クーポン割引料 - 300
     WHERE (注文日 BETWEEN '2024-03-12' AND '2024-03-14' ) AND 数量 >= 2 AND クーポン割引料 IS NOT NULL 
36. UPDATE 注文 
       SET 数量 = 数量 - 1
     WHERE 注文番号 = '202402250126' AND 商品コード = 'W0156'
37. SELECT 注文日 , 注文番号 || '-' || CAST(注文番号 AS VARCHAR) AS 注文番号 , 商品コード , 数量 , COALESCE(クーポン割引料 , 'なし')
      FROM 注文 
     WHERE 注文番号 BETWEEN '202310010001' AND '202310319999' 
38. SELECT DISTINCT 商品区分 , 
      CASE 商品区分 WHEN '1' THEN '衣類'
                   WHEN '2' THEN '靴'
                   WHEN '3' THEN '雑貨'
                   WHEN '9' THEN '未分類' END AS 区分名
      FROM 商品 
39. SELECT 商品コード , 商品名 , 単価 , 
      CASE WHEN 単価 >= 10000 THEN 'L'
           WHEN 単価 BETWEEN 3000 AND 9999 THEN 'M'
           WHEN 単価 < 3000 END AS 販売価格ランク , 
      商品区分 || ':' || CASE 商品区分 WHEN '1' THEN '衣類'
                                      WHEN '2' THEN '靴'
                                      WHEN '3' THEN '雑貨'
                                      WHEN '9' THEN '未分類' END AS 商品区分
      FROM 商品 
    ORDER BY 単価 , 商品コード 
40. SELECT 商品名 , LENGTH(商品名) AS 商品の文字数
      FROM 商品 
     WHERE LENGTH(商品名) > 10
    ORDER BY 2
41. SELECT 注文日 , SUBSTRING(注文番号 , 9 , 4) AS 注文番号 
      FROM 注文 
42. UPDATE 商品 
       SET 商品コード = REPLACE(商品コード , 'M' , 'E')
     WHERE SUBSTRING(商品コード , 1 , 1) = 'M'
43. SELECT SUBSTRING(注文番号 , 9 , 4) AS 注文番号 
      FROM 注文 
     WHERE SUBSTRING(注文番号 , 9 , 4) BETWEEN '1000' AND '2000'
    ORDER BY 1
44. UPDATE 廃番商品 
       SET 廃番日 = CURRENT_DATE
      WHERE 商品コード = 'S1990'
45. SELECT TRUNC(単価 * 0.7 , 0) AS 値下げした単価 , 商品コード , 商品名 , 単価
      FROM 商品 
     WHERE 単価 >= 10000
46. SELECT SUM(数量) AS 数量の合計 
      FROM 注文 
47. SELECT 注文日 , SUM(数量) AS 数量の合計
      FROM 注文 
     GROUP BY 注文日　
     ORDER BY 1
48. SELECT 商品区分 , MIN(単価) AS 単価の最小値 , MAX(単価) AS 単価の最大値
      FROM 商品 
    GROUP BY 商品区分
    ORDER BY 商品区分
49. SELECT 商品コード , SUM(数量) AS 数量の合計 
      FROM 商品 
    GROUP BY 商品コード 
    ORDER BY 商品コード 
50. SELECT 商品コード , SUM(数量) AS 数量の合計
      FROM 注文 
    GROUP BY 商品コード
    ORDER BY 数量 DESC , 商品コード 
    OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
51. SELECT 商品コード , SUM(数量) AS 数量の合計
      FROM 注文 
    GROUP BY 商品コード 
    HAVING SUM(数量) < 5
52. SELECT COUNT(クーポン割引料) AS 注文回数 , SUM(クーポン割引料)
      FROM 注文 
53. SELECT 
      FROM 注文 
    GROUP BY SUBSTRING(注文日 , )
54. SELECT 商品コード
      FROM 注文 
     WHERE SUBSTRING(商品コード , 1 , 1) = 'Z'
    GROUP BY 商品コード 
    HAVING SUM(数量) >= 100

55. SELECT 商品コード , 商品名 , 単価 ,
    (SELECT SUM(数量) FROM 注文 WHERE 商品コード = 'S0604') AS 数量  
      FROM 商品 
     WHERE 商品コード = 'S0604'
56. UPDATE 注文 
       SET 商品コード = (SELECT 商品コード 
                          FROM 商品 
                         WHERE 商品区分 = '2' AND 商品名 LIKE '%ブーツ%' AND 商品名 LIKE '%雨%' AND 商品名 LIKE '%安心%')
     WHERE 注文日 = '2023-03-15' AND 注文番号 = '202403150014' AND 注文枝番 = 1
57. SELECT 注文日 , 商品コード 
      FROM 注文 
     WHERE 商品コード IN (SELECT 商品コード 
                          FROM 商品 
                         WHERE 商品名 LIKE '%あったか%')
    ORDER BY 注文日 
58. SELECT 商品コード , SUM(数量) AS 販売数量 
      FROM 注文 
    GROUP BY 商品コード 
    HAVING 販売数量 / COUNT(*) > ALL (SELECT SUM(数量) / COUNT(商品コード) 
                                       FROM 注文 
                                      GROUP BY 商品コード)
59. SELECT COUNT(*) AS 割引による販売数 , TRUNC(SUM(クーポン割引料) / COUNT(*) , 0) AS 平均割引額
      FROM (SELECT * FROM 注文 WHERE 商品コード = 'W0746' AND クーポン割引料 IS NOT NULL)
60. INSERT INTO 注文 
    (注文日 , 注文番号 , 注文枝番 ,  商品コード , 数量)
    VALUES ('2024-03-21' , '202403210080' , (SELECT 注文枝番 
                                               FROM 注文 
                                              WHERE 注文番号 = '202403210080') + 1 , 'S1003' , 1)
     
     INSERT INTO 注文 
     VALUES ('2024-03-22' , '202403210080' , (SELECT 注文枝番
                                                FROM 注文 
                                               WHERE 注文番号 = '202403220901' + 1) , 'A0052' , 2 , 500)
61. SELECT T.注文番号 , T.注文枝番 , T.商品コード , S.商品名 , T.数量 
      FROM 注文 AS T  
      JOIN 商品 AS S 
        ON T.商品コード = S.商品コード 
     WHERE 注文番号 = '202401130115' 
    ORDER BY T.注文番号 , T.注文枝番
62. SELECT T.注文日 AS 注文日 , T.注文番号 AS 注文番号 , T.注文枝番 AS 注文枝番 , T.数量 , T.数量 * H.単価 AS 注文金額 
      FROM 注文 AS T 
      JOIN 廃番商品 AS H 
        ON T.商品コード = H.商品コード 
     WHERE T.注文日 > H.廃番日 AND H.商品コード = 'A0009'
63. SELECT S.商品コード AS 商品コード , S.商品名 AS 商品名 , S.単価 AS 単価 , T.注文日 AS 注文日 , T.注文番号 AS 注文番号 , T.数量 AS 数量 , S.単価 * T.数量 AS 売上金額 
      FROM 商品 AS S  
      JOIN 注文 AS T 
        ON S.商品コード = T.商品コード 
     WHERE S.商品コード = 'S0604'
    ORDER BY T.注文番号 
64. SELECT S.商品コード , S.商品名 
      FROM (SELECT 商品コード , 商品名 FROM 商品 
            EXCEPT 
            SELECT 商品コード , 商品名 FROM 廃番テーブル) AS S 
      JOIN 注文 AS T 
        ON S.商品コード = T.商品コード 
     WHERE T.注文日 BETWEEN '2022-08-01' AND '2022-08-31'
65. SELECT 
      FROM (SELECT 商品コード , 商品名 FROM 商品 
             UNION 
            SELECT 商品コード , '廃番' FROM 廃番商品) AS S
      JOIN 注文 AS T 
        ON S.商品コード = T.商品コード
66. SELECT T.注文日 , S.商品コード || ':' || S.商品名 AS 商品 , COALESCE(T.数量 , 0) AS 数量 
      FROM 商品 AS S 
      LEFT JOIN 注文 AS T 
             ON S.商品コード = T.商品コード 
     WHERE S.商品区分 = '3'
67. SELECT T.注文日 , COALESCE(S.商品コード , S.商品コード || ':' || '(廃番済み)') , S.商品名 , T.数量
      FROM 注文 AS T 
      LEFT JOIN 商品 AS S
             ON T.商品コード = S.商品コード 
     WHERE S.商品区分 = '3'☞この条件にすると商品区分がNULL(商品が廃番)
68. SELECT T.注文日 , T.注文番号 , T.注文枝番 , T.商品コード , 
      FROM 注文 AS T 
      JOIN 商品 AS S
        ON T.商品コード = COALESCE(S 
     WHERE T.注文番号 = '202304030010'
69. SELECT S.商品コード , S.商品名 , S.単価 , T.個数 , T.個数 * S.単価 AS 総売上金額    
      FROM 商品 AS S 
      JOIN (SELECT 商品コード , SUM(数量) AS 個数
              FROM 注文 
             GROUP BY 商品コード) AS T 
        ON S.商品コード = T.商品コード 
     WHERE S.商品コード LIKE 'B%'
     ORDER BY 商品コード
70. SELECT S1.商品コード , S1.商品名 , S2.商品コード AS 関連商品コード , S2.商品名 AS S2.関連商品名
      FROM 商品 AS S1 
      JOIN 商品 AS S2 
        ON S1.関連商品コード = S2.商品コード 

      



-----------------------------------------------商店データベースの正答----------------------------------------------
11. 11月以前のデータ→11月末までのデータ
    SELECT * 
      FROM 注文
     WHERE 注文日 > '2023-12-01'
30. SELECT * FROM 廃番商品 WHERE 廃番日 BETWEEN '2022-12-01' AND '2022-12-31'
     UNION 
    SELECT * FROM 廃版商品 WHERE 売上個数 > 100
    ORDER BY 売上個数 DESC
42. UPDATE 商品 
       SET 商品コード = 'E' || SUBSTRING(商品コード , 2 , 4)
     WHERE SUBSTRING(注文番号 , 9 , 4) AS 注文番号
*SET句でもSUBSTRING関数を用いるのは効率的ではないので上記のようにした方が効率的??

50. SELECT 商品コード , SUM(数量) AS 数量の合計
      FROM 注文 
    GROUP BY 商品コード
    ORDER BY 数量の合計 DESC , 商品コード 
    OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY

53. SELECT SUBSTRING(注文番号 , 1 , 6) AS 年月 , COUNT(*) AS 注文件数
      FROM 注文 
     WHERE 注文枝番 = '1' 
    GROUP BY SUBSTRING(注文番号 , 1 , 6) 
    ORDER BY SUBSTRING(注文番号 , 1 , 6) DESC
    *注文番号には８桁の日付が含まれている→そこから年月の部分だけ抽出した項目をとってくればいい
54. SELECT 商品コード
      FROM 注文 
     WHERE 商品コード LIKE 'Z%'
    GROUP BY 商品コード 
    HAVING SUM(数量) >= 100
    *文字列の先頭一致にはLIKE演算子を用いるほうが分かりやすい
58. SELECT 商品コード , SUM(数量) AS 数量 
      FROM 注文 
    GROUP BY 商品コード 
    HAVING SUM(数量) > ALL (SELECT AVG(数量) FROM 注文 GROUP BY 商品コード)
*選択列リストでエイリアスとして指定されている名前はHAVING句では使用することができない。
理由としては選択列リストが評価されるのは抽出の対象となる行が特定できたあとだから
平均を求めるにはSUM / COUNTをしなくてもAVGを使用することができる
59. SELECT A.数量合計 AS 割引による販売数 , TRUNC(A.割引料合計 / A.数量合計 , 0) AS 平均割引額 
      FROM (SELECT SUM(数量) AS 数量合計 , SUM(クーポン割引料) AS 割引料合計
              FROM 注文 
             WHERE 商品コード = 'W0746' AND クーポン割引料 IS NOT NULL) AS A 
60. INSERT INTO 注文 
    SELECT 注文日 , 注文番号 , MAX(注文枝番) + 1 , 'S1003' , 1 , NULL
      FROM 注文 
     WHERE 注文日 = '2024-03-21' AND 注文番号 = '202403210080'
    GROUP BY 注文日 , 注文番号
64. SELECT S.商品コード , S.商品名  
      FROM 商品 AS S 
      JOIN 注文 AS T 
        ON S.商品コード = T.商品コード 
     WHERE T.注文日 BETWEEN '2022-08-01' AND '2022-08-31'
65. SELECT  T.商品コード , COALESCE(S.商品名 , '廃番')
      FROM 商品 AS S 
      RIGHT JOIN 注文 AS T 
              ON S.商品コード = T.商品コード 
     WHERE T.注文日 BETWEEN '2022-08-01' AND '2022-08-31'
67. SELECT T.注文日 , S.商品コード || ':' || S.商品名 AS 商品 , COALESCE(T.数量 , 0) AS 数量 
      FROM 注文 AS T 
      RIGHT JOIN (SELECT 商品コード , 商品名 , 商品区分 FROM 商品
                   UNION 
                  SELECT 商品コード , '(廃番済み)' AS 商品名 , 商品区分 FROM 廃番商品) AS S 
              ON T.商品コード = S.商品コード 
     WHERE S.商品区分 = '3'
68. SELECT T.注文日 , T.注文枝番 , T.商品コード , COALESCE(S.商品名 , H.商品名) AS 商品名 , 
           COALESCE(S.単価 , H.単価) AS 単価 , T.数量 AS 数量 , COALESCE(S.単価 , H.単価) * T.数量 - COALESCE(T.クーポン割引料 , 0) AS 注文金額 
      FROM 注文 AS T 
      LEFT JOIN 商品 AS S 
             ON T.商品コード = S.商品コード 
      LEFT JOIN 廃番商品 AS H 
             ON T.商品コード = H.商品コード 
     WHERE T.注文番号 = '202304030010'

69. SELECT S.商品コード , S.商品名 , S.単価 , COALESCE(T.数量 , 0) AS 売上数量 , S.単価 * COALESCE(T.数量 , 0) AS 総売上金額 
      FROM 商品 AS S 
      LEFT JOIN (SELECT 商品コード , SUM(数量) AS 数量 
                   FROM 注文 
                  WHERE 商品コード LIKE 'B%'
                  GROUP BY 商品コード) AS T 
             ON S.商品コード = T.商品コード 
     WHERE S.商品コード LIKE 'B%' ORDER BY S.商品コード 
*注文があったかどうかにかかわらずすべての商品を取得するという設計ならJOINしたレコードのカラムがNULLになる可能性があるのでCOALESCEを用いてNULLの場合に対処する必要がある


70. SELECT S1.商品コード , S1.商品名 , S2.商品コード AS 関連商品コード , S2.商品名 AS 関連商品名 
      FROM 商品 AS S1 
      JOIN 商品 AS S2 
        ON S1.商品コード = S2.関連商品コード 
*この問題ではAに関連している商品があれば(商品Aのレコードの中の関連商品欄に何かが入っているという状況ではなく、Aが関連している商品)
それを取得するという問題

